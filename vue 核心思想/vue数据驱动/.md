## Vue 数据驱动原理
> 一句话概括：不直接操作DOM，通过修改数据来改变视图层的变化。

### new Vue 的过程发生了什么
> `new` 是一个创建钩爪函数实例的关键字，`Vue` 是一个类，在 Javascript 中 `Vue` 就是一个构造函数。`vue` 会将 `options` 合并同时初始化所有的数据，将属性和方法挂载到 `vue` 的实例上。
``` js
// vue\src\core\instance>index.js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```
> 上面的`_init()`方法会初始化`Vue` 中的属性 `data/methods等等`。
* 首先会合并传入的对象，`merge options`。
* 初始化声明周期`initLifecycle(vm)`。
* `initData()` 方法初始化 data 对象 ，将遍历 `data` 中的属性名通过 `proxy()` 挂载`Object.defineProperty()`到 `vue` 的实例上，那么就可以通过 `this.` 的方式获取到 `data` 对象的属性值，挂载的之前 `vue` 会做一些`data/methods/props`属性名上的排除，保证三者的属性名不会一致
``` js
function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm):data || {};
    if(){
        ...
    }
    proxy(vm, "_data", key);
    // observe data
    observe(data, true /* asRootData */ );
}
function proxy(target, sourceKey, key) {
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
```
* 和初始化`data`类试也会初始化 `methods/props/computed/watch等属性`。
* `_init()` 方法的最后通过`$mount()`将`el`挂载到页面上去。

### Vue 是如何挂载 el 到 DOM 上面的
> 了解`vm.$mount()`方法的实现，就可以知道 vue 是如何挂载道页面上的。
* `query` 是对传入的 `el` 进行判断和相应的处理可以是一个字符串也可以是一个 `DOM` 对象，同时排除挂载的`DOM`节点对象不可以是`html/body`等元素。
* 在挂载的过程中对`option.render`方法进行判断，如果没有定义`render`方法那么最后会将`template/el`等属性最后还是会通过`render` 方法来进行渲染`虚拟DOM`
* `mountComponent`，
``` js
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
};

Vue.prototype.$mount = function (el,hydrating) {
    el = el && query(el);
    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      warn(
        "Do not mount Vue to <html> or <body> - mount to normal elements instead."
      );
      return this
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if (!template) {
              warn(
                ("Template element not found or is empty: " + (options.template)),
                this
              );
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          outputSourceRange: "development" !== 'production',
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile end');
          measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating)
  };
```