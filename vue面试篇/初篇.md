# Vue 必知必会的面试题
> 编译原理 compile，响应式原理 observe，虚拟dom 和 diff算法。

## 面试题
### 1. MPA/SPA 的理解，优缺点是什么？
__`MPA` 多页面应用。__
* 构成：有多个页面 `html` 构成，
* 跳转方式：页面的跳转是从一个页面到另一个页面
* 刷新的方式：全页面刷新
* 页面数据跳转：依赖`URL/cookie/localStorage`
* 跳转后的资源`会重新加载`
* 优点：对 SEO 比较友好，开发难度第一点。
__`SPA`单页面应用__
* 页面组成：由一个外壳页面包裹，多个页面(组件)片段组成
* 跳转方式：在外壳页面中跳转，将片段页面(组件)显示或隐藏
* 刷新方式：页面片段的局部刷新
* 页面的数据跳转：组件间的传值比较容易
* 跳转后的资源`不会重新加载`
* 缺点：对 SEO 搜索不太友好需要单独做配置，开发难度高一点需要专门的开发框架 
> iframe 实际上是 `MPA`，但是可以实现`SPA`的一些效果，但是本身由不少问题。

### 使用 vue2.x 实例添加的属性具备响应式变化吗？
* 不具备，因为 vue 只对已经存在 `data` 上面的属性添加响应式的变化，后来添加到 `data` 的属性需要通过全局 api，`$set` 添加才具备响应式的变化。

### vue2.x 中对数组的下标有做代理(数据劫持)吗？vue 是怎么对数组做代理的？
* vue2.x 没有对数组的每一个下标做数据拦截，如果数组的元素很大且存在嵌套的话，性能消耗是很大的
* vue2.x 通过重写数组的常用方法 `push pop shift unshift reverse sort splice` 来给数组做数据拦截，因为这几个方法会改变原数组。
* vue2.x 为数组中的 `object` 类型添加 `Object.definedProperty(obj, key, {})`。

### vue2.x 中是怎么做数据劫持的
* 基本类型已经在 `data` 中的会直接使用 `Object.definedPrototype()` 进行数据劫持，后来添加的需要通过 `$set` 做数据劫持
* 对象类型会对对象不停的进行递归使用 `Object.definedPrototype()` 进行数据劫持，后来添加的需要通过 `$set` 做数据劫持
* 数组的数组劫持，通过劫持数组的方法，对数组中的引用类型进行数据劫持，对其他类型不做数据劫持，后来添加的需要通过 `$set` 做数据劫持

### proxy 和 Object.definedProperty
* `Object.definedProperty` 是为了给 vue 中的 `data` 属性的对象添加 `get/set` 实现响应式的变化，如果 `data` 中嵌套了很多层对象的话，那么需要递归的次数就越深，性能消耗大
* vue3 中 `proxy` 能够很好的处理对象嵌套的问题，不需要递归，也不需要添加`get/set`

### 模板编译原理
* vue 中模板编译的元素挂载优先级 `render> template> el`。
* 如果只有 `el` 通过正则处理 `html` 词法解析(开始标签，结束标签，属性和文本) html， 通过`栈构建 AST 语法树`，经过 `render()` 函数产生`虚拟 dom`，再使用 `diff` 算法更新虚拟 `dom`，最后一步生成 `真实DOM`。
* vue2.x 中的模板编译使用正则表达式逐步从每一个标签的 `<` 开始匹配，逐步匹配标签内的属性和值。正则匹配 `{{}}` 的内容，最后匹配标签的闭合。匹配到的内容都放入到一个栈中。
* 将匹配解析后结果，使用 `栈` 组成一个树结构。将节点一层层的放入到栈中，遇到闭合的节点就弹出挂载到父节点下(这个父节点的确定就是弹出节点的上一个元素栈顶元素)。这个过程就是 `AST语法树` 的构建。


### AST 语法树
* ast 语法树是用来描述的 `html` 语法的，使用 js 对象来描述语法 
``` js
{tag: "div", type: 1, attrs: Array(1), children: Array(0), parent: null}
```

### render 函数
* `render` 利用 `new Function() 和 with` 将传入 `ast语法树` 实现 `虚拟dom`，
* 在 vue 的 `{{}}` 不使用 `this` 获取实例上的属性和方法也可以，因为在 `render` 函数中使用 `with`，`with(this)` 中的 this，经过 `render.call(vm)` 将 `this` 指向 vue 实例 `vm`，所以可以直接使用实例上的属性，可以不需要 `this`。
``` js
render: ("with(this){return " + code + "}")

render.call(vm)
```

### 虚拟 DOM (VNode) 
* vue 通过将 `render` 函数返回的虚拟 dom 传递给 `vm._update(vm._render())` 更新渲染成真实 dom
* 真实 dom 更新前都会对比每次的虚拟 dom 的差别

### diff算法，它如何去优化这个渲染的计算或者优化效率的？


### mountComponent 组件挂载钩子
* 将组件的实例挂载到 `el` 上。
* 内部有组件首次挂载和组件更新时执行的方法 `updateComponent`。
``` js
function mountComponent(vm, el) {
    let updateComponent = () => {
        vm._update(vm._render())
    }
}
``

[vue面试重点](https://juejin.cn/post/6961222829979697165)
