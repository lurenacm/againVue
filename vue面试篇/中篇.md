## 面试题篇

### 1.老生常谈之， MPA/SPA 的理解，优缺点是什么？
__`MPA` 多页面应用。__
* 构成：有多个页面 `html` 构成，
* 跳转方式：页面的跳转是从一个页面到另一个页面
* 刷新的方式：全页面刷新
* 页面数据跳转：依赖 `URL/cookie/localStorage`
* 跳转后的资源 `会重新加载`
* 优点：对 SEO 比较友好，开发难度低一点。
__`SPA`单页面应用__
* 页面组成：由一个外壳页面包裹，多个页面(组件)片段组成
* 跳转方式：在外壳页面中跳转，将片段页面(组件)显示或隐藏
* 刷新方式：页面片段的局部刷新
* 页面的数据跳转：组件间的传值比较容易
* 跳转后的资源 `不会重新加载` 
* 缺点：对 SEO 搜索不太友好需要单独做配置，开发难度高一点需要专门的开发框架 
> iframe 实际上是 `MPA`，但是可以实现 `SPA` 的一些效果，但是本身由不少问题。

### 2.老生常谈之，为什么需要有这些 MVC/MVVM 模式？谈谈你对 MVC，MVVM 模式的区别，
> __目的：借鉴后端的思想，职责划分和分层__
* Vue, React 不是真正意义上的 MVVM 更不是 MVC，两者核心只处理视图层 `view`。

__MVC模式__

[MVC](./MVC.jpg)
> 单向的数据，用户的每一步操作都需要重新请求数据库来修改视图层的渲染，形成一个单向的闭环。比如 `jQuery+underscore+backbone`。
* M：`model` 数据存放层
* V: `view`：视图层 页面
* C: `controller`：控制器 js 逻辑层。
> `controller` 控制层将数据层 `model层` 的数据处理后显示在视图层 `view层`，同样视图层 `view层` 接收用户的指令也可以通过控制层 `controller`，作用到数据层 `model`。所以 `MVC的缺点是视图层不能和数据层直接交互。`

__MVVM模式__
> 隐藏了 `controller` 控制层，直接操控 `View` 视图层和 `Model` 数据层。
[MVVM](./MVVM.jpg)
* M：model 数据模型
* V: view 视图模板
* VM：view-model 视图数据模板(vue处理的层，vue 中的definedProperty 就是处理 VM 层的逻辑)
> 双向的数据绑定：`model` 数据模型层通过数据绑定 `Data Bindings` 直接影响视图层 `View`，同时视图层 `view` 通过监听 `Dom Listener` 也可以改变数据模型层 `model`。
* 数据绑定和DOM事件监听就是 `viewModel` 层 `Vue` 主要做的事。也就是说：只要将 `数据模型层Model` 的数据挂载到 `ViewModel` 层 `Vue` 就可以实现双向的数据绑定。
* 加上 `vuex/redux` 可以作为 `vue和react` 的 `model` 数据层。
``` js
var vm = new Vue()
```
> vm 就是 `view-model` 数据模型层，data：就是vm `view-model` 层所代理的数据。

* 综上两者的区别：MVC 的视图层和数据层交互需要通过控制层 `controller` 属于单向链接。MVVM 隐藏了控制层 `controller`，让视图层和数据层可以直接交互 属于双向连接。


## 3. 说一下对 Vue 中响应式数据的理解
> 小tip：响应式数据指的是数据发生了变化，视图可以更新就是响应式的数据
* `vue` 中实现了一个 `definedReactive` 方法，方法内部借用 `Object.definedProperty()` 给每一个属性都添加了 `get/set` 的属性。
* `definedReactive` 只能监控到最外层的对象，对于内层的对象需要递归劫持数据。
* 数组则是重写的7个 `push pop shift unshift reverse sort splice` 来给数组做数据拦截，因为这几个方法会改变原数组
* 扩展：
``` js
// src\core\observer\index.js
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 准备给属性添加一个 dep 来依赖收集 Watcher 用于更新视图。
  const dep = new Dep()
  // some code

  // observe() 用来观察值的类型，如果是属性也是对象就递归，为每个属性都加上`get/set`
  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
        // 这里取数据时依赖收集
        const value = getter ? getter.call(obj) : val
        if (Dep.target) {
            dep.depend()
            // childOb 是对对像进行收集依赖
            if (childOb) {
                childOb.dep.depend()

                //这里对数组和内部的数组进行递归收集依赖，这里数组的 key 和 value 都有dep。
                if (Array.isArray(value)) {
                    dependArray(value)
                }
            }
        }
        return value
    },
    set: function reactiveSetter (newVal) {
      // some code
    }
  })
}
```
> 上面的 Dep(类) 是用来干嘛的？答：用来收集渲染的 `Watcher`，`Watcher` 又是一个啥东西？答：`watcher` 是一个类，用于更新视图的

## 4. Vue 是怎么检测数组的变化的？
* vue 没有对数组的每一项用`definedProperty()`来数据拦截，而是通过重写数组的方法`push pop shift unshift reverse sort splice`。
* 数组中如果有对象类型(`对象和数组`)的话会进行数据拦截。
* 所以通过修改数组下标和数组长度是不会进行数据拦截的，也就不会有响应式变化。
* 扩展：
``` js
// src\core\observer\array.js
const methodsToPatch = ['push','pop','shift','unshift','splice','sort','reverse']
methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    ob.dep.notify()
    return result
  })
})

```










